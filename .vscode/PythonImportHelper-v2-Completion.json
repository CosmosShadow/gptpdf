[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "fitz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fitz",
        "description": "fitz",
        "detail": "fitz",
        "documentation": {}
    },
    {
        "label": "shapely.geometry",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shapely.geometry",
        "description": "shapely.geometry",
        "detail": "shapely.geometry",
        "documentation": {}
    },
    {
        "label": "BaseGeometry",
        "importPath": "shapely.geometry.base",
        "description": "shapely.geometry.base",
        "isExtraImport": true,
        "detail": "shapely.geometry.base",
        "documentation": {}
    },
    {
        "label": "explain_validity",
        "importPath": "shapely.validation",
        "description": "shapely.validation",
        "isExtraImport": true,
        "detail": "shapely.validation",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "dotenv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dotenv",
        "description": "dotenv",
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "parse_pdf",
        "kind": 2,
        "importPath": "gptpdf.parse",
        "description": "gptpdf.parse",
        "peekOfCode": "def parse_pdf(\n        pdf_path: str,\n        output_dir: str = './',\n        prompt: Optional[Dict] = None,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        model: str = 'gpt-4o',\n        verbose: bool = False,\n        gpt_worker: int = 1\n) -> Tuple[str, List[str]]:",
        "detail": "gptpdf.parse",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PROMPT",
        "kind": 5,
        "importPath": "gptpdf.parse",
        "description": "gptpdf.parse",
        "peekOfCode": "DEFAULT_PROMPT = \"\"\"使用markdown语法，将图片中识别到的文字转换为markdown格式输出。你必须做到：\n1. 输出和使用识别到的图片的相同的语言，例如，识别到英语的字段，输出的内容必须是英语。\n2. 不要解释和输出无关的文字，直接输出图片中的内容。例如，严禁输出 “以下是我根据图片内容生成的markdown文本：”这样的例子，而是应该直接输出markdown。\n3. 内容不要包含在```markdown ```中、段落公式使用 $$ $$ 的形式、行内公式使用 $ $ 的形式、忽略掉长直线、忽略掉页码。\n再次强调，不要解释和输出无关的文字，直接输出图片中的内容。\n\"\"\"\nDEFAULT_RECT_PROMPT = \"\"\"图片中用红色框和名称(%s)标注出了一些区域。\n如果区域是表格或者图片，使用 ![]() 的形式插入到输出内容中，否则直接输出文字内容。\n\"\"\"\nDEFAULT_ROLE_PROMPT = \"\"\"你是一个PDF文档解析器，使用markdown和latex语法输出图片的内容。",
        "detail": "gptpdf.parse",
        "documentation": {}
    },
    {
        "label": "DEFAULT_RECT_PROMPT",
        "kind": 5,
        "importPath": "gptpdf.parse",
        "description": "gptpdf.parse",
        "peekOfCode": "DEFAULT_RECT_PROMPT = \"\"\"图片中用红色框和名称(%s)标注出了一些区域。\n如果区域是表格或者图片，使用 ![]() 的形式插入到输出内容中，否则直接输出文字内容。\n\"\"\"\nDEFAULT_ROLE_PROMPT = \"\"\"你是一个PDF文档解析器，使用markdown和latex语法输出图片的内容。\n\"\"\"\ndef _is_near(rect1: BaseGeometry, rect2: BaseGeometry, distance: float = 20) -> bool:\n    \"\"\"\n    Check if two rectangles are near each other if the distance between them is less than the target.\n    \"\"\"\n    return rect1.buffer(0.1).distance(rect2.buffer(0.1)) < distance",
        "detail": "gptpdf.parse",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ROLE_PROMPT",
        "kind": 5,
        "importPath": "gptpdf.parse",
        "description": "gptpdf.parse",
        "peekOfCode": "DEFAULT_ROLE_PROMPT = \"\"\"你是一个PDF文档解析器，使用markdown和latex语法输出图片的内容。\n\"\"\"\ndef _is_near(rect1: BaseGeometry, rect2: BaseGeometry, distance: float = 20) -> bool:\n    \"\"\"\n    Check if two rectangles are near each other if the distance between them is less than the target.\n    \"\"\"\n    return rect1.buffer(0.1).distance(rect2.buffer(0.1)) < distance\ndef _is_horizontal_near(rect1: BaseGeometry, rect2: BaseGeometry, distance: float = 100) -> bool:\n    \"\"\"\n    Check if two rectangles are near horizontally if one of them is a horizontal line.",
        "detail": "gptpdf.parse",
        "documentation": {}
    },
    {
        "label": "test_use_api_key",
        "kind": 2,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "def test_use_api_key():\n    from gptpdf import parse_pdf\n    api_key = os.getenv('OPENAI_API_KEY')\n    base_url = os.getenv('OPENAI_API_BASE')\n    # Manually provide OPENAI_API_KEY and OPEN_API_BASE\n    content, image_paths = parse_pdf(pdf_path, output_dir=output_dir, api_key=api_key, base_url=base_url, model='gpt-4o', gpt_worker=6)\n    print(content)\n    print(image_paths)\n    # also output_dir/output.md is generated\ndef test_use_env():",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "test_use_env",
        "kind": 2,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "def test_use_env():\n    from gptpdf import parse_pdf\n    # Use OPENAI_API_KEY and OPENAI_API_BASE from environment variables\n    content, image_paths = parse_pdf(pdf_path, output_dir=output_dir, model='gpt-4o', verbose=True)\n    print(content)\n    print(image_paths)\n    # also output_dir/output.md is generated\ndef test_azure():\n    from gptpdf import parse_pdf\n    api_key = '8ef0b4df45e444079cd5a4xxxxx' # Azure API Key",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "test_azure",
        "kind": 2,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "def test_azure():\n    from gptpdf import parse_pdf\n    api_key = '8ef0b4df45e444079cd5a4xxxxx' # Azure API Key\n    base_url = 'https://xxx.openai.azure.com/' # Azure API Base URL\n    model = 'azure_xxxx' # azure_ with deploy ID name (not open ai model name), e.g. azure_cpgpt4\n    # Use OPENAI_API_KEY and OPENAI_API_BASE from environment variables\n    content, image_paths = parse_pdf(pdf_path, output_dir=output_dir, api_key=api_key, base_url=base_url, model=model, verbose=True)\n    print(content)\n    print(image_paths)\nif __name__ == '__main__':",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "pdf_path",
        "kind": 5,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "pdf_path = '../examples/attention_is_all_you_need.pdf'\noutput_dir = '../examples/attention_is_all_you_need/'   \npdf_path = '../examples/rh.pdf'\noutput_dir = '../examples/rh/'\n# 清空output_dir\nimport shutil\nshutil.rmtree(output_dir, ignore_errors=True)\ndef test_use_api_key():\n    from gptpdf import parse_pdf\n    api_key = os.getenv('OPENAI_API_KEY')",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "output_dir = '../examples/attention_is_all_you_need/'   \npdf_path = '../examples/rh.pdf'\noutput_dir = '../examples/rh/'\n# 清空output_dir\nimport shutil\nshutil.rmtree(output_dir, ignore_errors=True)\ndef test_use_api_key():\n    from gptpdf import parse_pdf\n    api_key = os.getenv('OPENAI_API_KEY')\n    base_url = os.getenv('OPENAI_API_BASE')",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "pdf_path",
        "kind": 5,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "pdf_path = '../examples/rh.pdf'\noutput_dir = '../examples/rh/'\n# 清空output_dir\nimport shutil\nshutil.rmtree(output_dir, ignore_errors=True)\ndef test_use_api_key():\n    from gptpdf import parse_pdf\n    api_key = os.getenv('OPENAI_API_KEY')\n    base_url = os.getenv('OPENAI_API_BASE')\n    # Manually provide OPENAI_API_KEY and OPEN_API_BASE",
        "detail": "test.test",
        "documentation": {}
    },
    {
        "label": "output_dir",
        "kind": 5,
        "importPath": "test.test",
        "description": "test.test",
        "peekOfCode": "output_dir = '../examples/rh/'\n# 清空output_dir\nimport shutil\nshutil.rmtree(output_dir, ignore_errors=True)\ndef test_use_api_key():\n    from gptpdf import parse_pdf\n    api_key = os.getenv('OPENAI_API_KEY')\n    base_url = os.getenv('OPENAI_API_BASE')\n    # Manually provide OPENAI_API_KEY and OPEN_API_BASE\n    content, image_paths = parse_pdf(pdf_path, output_dir=output_dir, api_key=api_key, base_url=base_url, model='gpt-4o', gpt_worker=6)",
        "detail": "test.test",
        "documentation": {}
    }
]